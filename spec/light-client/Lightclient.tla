---------------------------- MODULE Lightclient ----------------------------
(*
 * A state-machine specification of the light client, following the English spec:
 * https://github.com/tendermint/tendermint/blob/master/docs/spec/consensus/light-client.md
 *
 * Whereas the English specification presents the light client as a piece of sequential code,
 * which contains non-tail recursion, we specify a state machine that explicitly has
 * a stack of requests in its state. This specification can be easily extended to support
 * multiple requests at the same time, e.g., to reduce latency.
 *) 

EXTENDS Integers, Sequences

\* the parameters of Lite Client
CONSTANTS
  TRUSTED_HEIGHT,
    (* an index of the block header that the light client trusts by social consensus *)
  TO_VERIFY_HEIGHT
    (* an index of the block header that the light client tries to verify *)

VARIABLES       (* see TypeOK below for the variable types *)
  state,        (* the current state of the light client *)
  inEvent,      (* an input event to the light client, e.g., a header from a full node *)
  outEvent,     (* an output event from the light client, e.g., finished with a verdict *)
  requestStack,     (* the stack of requests to be issued by the light client to a full node *)
  storedHeaders     (* the set of headers obtained from a full node*) 

(* the variables of the lite client *)  
lcvars == <<state, outEvent, requestStack, storedHeaders>>  

(* the variables of the client's environment, that is, input events *)
envvars == <<inEvent>>  

(******************* Blockchain instance ***********************************)

\* the parameters that are propagated into Blockchain
CONSTANTS
  AllNodes,
    (* a set of all nodes that can act as validators (correct and faulty) *)
  ULTIMATE_HEIGHT,
    (* a maximal height that can be ever reached (modelling artifact) *)
  MAX_POWER
    (* a maximal voting power of a single node *)

\* the state variables of Blockchain, see Blockchain.tla for the details
VARIABLES tooManyFaults, height, minTrustedHeight, blockchain, Faulty

\* All the variables of Blockchain. For some reason, BC!vars does not work
bcvars == <<tooManyFaults, height, minTrustedHeight, blockchain, Faulty>>

(* Create an instance of Blockchain.
   We could write EXTENDS Blockchain, but then all the constants and state variables
   would be hidden inside the Blockchain module.
 *) 
BC == INSTANCE Blockchain WITH tooManyFaults <- tooManyFaults, height <- height,
  minTrustedHeight <- minTrustedHeight, blockchain <- blockchain, Faulty <- Faulty

(************************** Environment ************************************)
NoEvent == [type |-> "None"]

InEvents ==
        (* start the client given the height to verify (fixed in our modelling) *)
    [type: {"start"}, heightToVerify: BC!Heights]
       \union
        (* receive a signed header that was requested before *)
    [type: {"responseHeader"}, hdr: BC!SignedHeaders]
        \union
    {NoEvent}
    (* most likely, the implementation will have a timeout event, we do not need it here *)

(* initially, the environment is not issuing any requests to the lite client *)
EnvInit ==
    inEvent = NoEvent
    
(* The events that can be generated by the environment (reactor?):
    user requests and node responses *)
EnvNext ==
    (* send a request from the client asking to verify the header at the height heightToVerify *)
    \/ /\ state = "init"
       \* modeling feature, do not start the client before the blockchain is constructed
       /\ height >= TO_VERIFY_HEIGHT
       /\ inEvent' = [type |-> "start", heightToVerify |-> TO_VERIFY_HEIGHT]
    (* send a response from a full node, following the request for header from the light client *)
    \/ /\ state = "working"
       /\ outEvent.type = "requestHeader"
       /\ \E hdr \in BC!SoundSignedHeaders(outEvent.height):
            (* produce an arbitrary header that is either:
               (1) signed by the validators who committed the block, and the block is correct, or
               (2) signed by some faulty validators. *)
            inEvent' = [type |-> "responseHeader", hdr |-> hdr]
            \* if you like to see a counterexample, replace SoundSignedHeaders with SignedHeaders

(************************** Lite client ************************************)

(* the control states of the lite client *) 
States == { "init", "working", "finished" }

(* the events that can be issued by the lite client *)    
OutEvents ==
        (* request the header for a given height from the peer full node *)
    [type: {"requestHeader"}, height: BC!Heights]
        \union
        (* finish the check with a verdict *)
    [type: {"finished"}, verdict: BOOLEAN]  
        \union
    {NoEvent}      

(* Produce a request event for the top element of the requestStack *)
RequestHeaderForTopRequest(stack) ==
    IF stack = <<>>
    THEN NoEvent
    ELSE  LET top == Head(stack)
              heightToRequest ==
                IF top.isLeft
                THEN top.endHeight      \* the pivot is on the right
                ELSE top.startHeight    \* the pivot is on the left
          IN
          [type |-> "requestHeader", height |-> heightToRequest]

(* When starting the light client *)
OnStart ==
    /\ state = "init"
    /\ inEvent.type = "start"
    /\ state' = "working"
        (* the block at trusted height is obtained by the user *)
        \* TODO: the English spec does not make this explicit
    /\ storedHeaders' = { << blockchain[TRUSTED_HEIGHT],
                             DOMAIN blockchain[TRUSTED_HEIGHT].VP >> }
        (* The only request on the stack ("left", h1, h2) *)
    /\ IF TRUSTED_HEIGHT < TO_VERIFY_HEIGHT
       THEN
         LET initStack == << [isLeft |-> TRUE,
                              startHeight |-> TRUSTED_HEIGHT,
                              endHeight |-> inEvent.heightToVerify] >>
         IN
         /\ requestStack' = initStack
         /\ outEvent' = RequestHeaderForTopRequest(initStack)
       ELSE
         \* TODO: update the English spec to address h1 = h2
         \*       (otherwise, the light client would not terminate)
         \* TODO: implement the downward verification?
         /\ outEvent' = [type |-> "finished", verdict |-> TRUE]
         /\ UNCHANGED requestStack

(**
 Check whether commits in a signed header are correct with respect to the given
 validator set (DOMAIN votingPower) and votingPower.
 *)
Verify(votingPower, signedHdr) ==
    \* the implementation should check the hashes and other properties of the header
    LET TP == BC!PowerOfSet(votingPower, DOMAIN votingPower)
        SP == BC!PowerOfSet(votingPower,
                            signedHdr[2] \intersect DOMAIN votingPower)
    IN
        \* the commits are signed by the validators
    /\ signedHdr[2] \subseteq DOMAIN signedHdr[1].VP
        \* the 2/3s rule works
    /\ 3 * SP > 2 * TP

(* 
 Check whether we can trust the signedHdr based on trustedHdr
 following the trusting period method.
 This operator is similar to CheckSupport in the English spec.
   
 The parameters have the following meanings:
   - heightToTrust is the height of the trusted header
   - heightToVerify is the height of the header to be verified
   - trustedHdr is the trusted header (not a signed header)
   - signedHdr is the signed header to verify (including commits)
 *)
CheckSupport(heightToTrust, heightToVerify, trustedHdr, signedHdr) ==
    IF minTrustedHeight > heightToTrust \* outside of the trusting period
    THEN FALSE
    ELSE
      IF heightToVerify = heightToTrust + 1 \* adjacent headers
      THEN signedHdr[1].VP = trustedHdr.NextVP
      ELSE \* the general case: check 1/3 between the headers  
        LET TP == BC!PowerOfSet(trustedHdr.NextVP, DOMAIN trustedHdr.NextVP)
            SP == BC!PowerOfSet(trustedHdr.NextVP,
              signedHdr[2] \intersect DOMAIN trustedHdr.NextVP)
        IN
        3 * SP > TP

(* Make one step of bisection, roughly one stack frame of Bisection in the English spec *)
OneStepOfBisection(storedHdrs) ==
    LET topReq == Head(requestStack)
        lh == topReq.startHeight
        rh == topReq.endHeight
        lhdr == CHOOSE hdr \in storedHdrs: hdr[1].height = lh
        rhdr == CHOOSE hdr \in storedHdrs: hdr[1].height = rh
    IN
    IF Verify(lhdr[1].NextVP, rhdr) = FALSE
    THEN <<FALSE, <<(* empty stack *)>> >> \* TERMINATE immediately
    ELSE \* pass only the header lhdr[1] and signed header rhdr
      IF CheckSupport(lh, rh, lhdr[1], rhdr)
        (* The header can be trusted, pop the request and return true *)
      THEN <<TRUE, Tail(requestStack)>>
      ELSE IF lh + 1 = rh \* sequential verification
        THEN (* Sequential verification tells us that the header cannot be trusted. *)
            <<FALSE, << (* empty stack *)>> >> \* TERMINATE immediately
        ELSE (*
             Dichotomy: schedule search requests for the left and right branches
             (and pop the top element off the stack).
             In contrast to the English spec, these requests are not processed immediately,
             but one-by-one in a depth-first order.
             *)
            LET rightReq == [isLeft |-> FALSE, startHeight |-> (lh + rh) \div 2, endHeight |-> rh]
                leftReq ==  [isLeft |-> TRUE, startHeight |-> lh, endHeight |-> (lh + rh) \div 2]
            IN
            <<TRUE, <<leftReq, rightReq>> \o Tail(requestStack)>>

(*
 This is where the main loop of bisection is happening.
 The action is activated by a response from a full node.
 *)
OnResponseHeader ==
  /\ state = "working"
  /\ inEvent.type = "responseHeader"
  /\ storedHeaders' = storedHeaders \union { inEvent.hdr }  \* save the header
  /\ LET res == OneStepOfBisection(storedHeaders')          \* do one step
         verdict == res[1]
         newStack == res[2]
     IN
      /\ requestStack' = newStack
      /\ IF newStack = << >>            \* end of the bisection
         THEN /\ outEvent' = [type |-> "finished", verdict |-> verdict]
              /\ state' = "finished"    \* finish with the given verdict
         ELSE /\ outEvent' = RequestHeaderForTopRequest(newStack)
              /\ state' = "working"     \* continue

(*
 Initial states of the light client. No requests on the stack, no headers.
 *)
LCInit ==
    /\ state = "init"
    /\ outEvent = NoEvent
    /\ requestStack = <<>>
    /\ storedHeaders = {}

(*
 Actions of the light client: start or do bisection when receiving response.
 *)
LCNext ==
  OnStart \/ OnResponseHeader
            
            
(********************* Lite client + Environment + Blockchain *******************)
Init ==
    BC!Init /\ EnvInit /\ LCInit

(*
  A system step is made by one of the three components:
    (1) light client, (2) environment (user + full node), (3) blockchain.
 *)
Next ==
    \/ LCNext  /\ UNCHANGED bcvars /\ UNCHANGED envvars
    \/ EnvNext /\ UNCHANGED bcvars /\ UNCHANGED lcvars
    \/ BC!Next /\ UNCHANGED lcvars /\ UNCHANGED envvars

(************************* Types ******************************************)

TypeOK ==
    /\ state \in States
    /\ inEvent \in InEvents
    /\ outEvent \in OutEvents
    /\ requestStack \in Seq([isLeft: BOOLEAN, startHeight: BC!Heights, endHeight: BC!Heights])
    /\ storedHeaders \subseteq BC!SignedHeaders

(************************* Properties ******************************************)

(* The properties to check *)
\* check this property to get an example of a terminating light client
NeverStart == state /= "working"

NeverFinishNegative ==
  ~(outEvent.type = "finished" /\ outEvent.verdict = FALSE)

NeverFinishPositive ==
  ~(outEvent.type = "finished" /\ outEvent.verdict = TRUE)

NeverFinishPositiveWithFaults ==
  ~(outEvent.type = "finished" /\ outEvent.verdict = TRUE /\ tooManyFaults)

\* Correctness states that all the obtained headers are exactly like in the blockchain.
\* This formula is equivalent to Accuracy in the English spec, that is, A => B iff ~A => ~B.
CorrectnessInv ==
    outEvent.type = "finished" /\ outEvent.verdict = TRUE
        => (\A hdr \in storedHeaders: hdr[1] = blockchain[hdr[1].height])

PrecisionInv ==
    outEvent.type = "finished" /\ outEvent.verdict = FALSE
        => (\E hdr \in storedHeaders: hdr[1] /= blockchain[hdr[1].height])

\* There are no two headers of the same height
NoDupsInv ==
    \A hdr1, hdr2 \in storedHeaders:
      (hdr1.height = hdr2.height) => (hdr1 = hdr2)

\* TODO: check that the sequence of the headers in storedHeaders satisfies checkSupport pairwise

\* The lite client must always terminate under the given pre-conditions.
\* E.g., assuming that the full node always replies.
TerminationPre ==
       \* the user and the full node take steps, if they can
    /\ WF_envvars(EnvNext)
       \* and the lite client takes steps, if it can
    /\ WF_lcvars(LCNext)
       \* eventually, the blockchain is sufficiently high, and
       \* the blockchain is never dead, see NeverStuck in Blockchain.tla
    /\ <>[](height >= minTrustedHeight /\ height >= TO_VERIFY_HEIGHT)

\* Given the preconditions, the lite client eventually terminates.        
Termination ==
  TerminationPre => <>(outEvent.type = "finished")        

\* This property states that whenever the light client finishes with a positive outcome,
\* the trusted header is still within the trusting period.
\* The current spec most likely violates this property.
PositiveBeforeTrustedHeaderExpires ==
    (outEvent.type = "finished" /\ outEvent.verdict = TRUE)
        => (minTrustedHeight <= TRUSTED_HEIGHT)

\* TODO: specify Completeness, which is a combination of Termination and Precision.
\* TODO: Completeness in the English spec assumes that the lite client communicates
\* with a correct full node.  

(************************** MODEL CHECKING ************************************)
(*
  # Experiment 1.
  Run TLC with the following parameters:
  
  ULTIMATE_HEIGHT <- 3,
  MAX_POWER <- 1,
  TO_VERIFY_HEIGHT <- 3,
  TRUSTED_HEIGHT <- 1,
  AllNodes <- { A_p1, A_p2, A_p3, A_p4 } \* choose symmetry reduction for model values
  
  Did not finish after 2:30 hours (> 5.3M states):
  
   * Deadlocks: a deadlock occurs when minTrustedHeight > height.
   * Correctness: ???
   * Precision: ???
 *)
 
(*
  # Experiment 2.
  Run TLC with the following parameters:
  
  ULTIMATE_HEIGHT <- 2,
  MAX_POWER <- 1,
  TO_VERIFY_HEIGHT <- 2,
  TRUSTED_HEIGHT <- 1,
  AllNodes <- { A_p1, A_p2, A_p3, A_p4 } \* choose symmetry reduction for model values
  
  * Check Termination (liveness property).
 *)

=============================================================================
\* Modification History
\* Last modified Wed Nov 06 21:05:32 CET 2019 by igor
\* Created Wed Oct 02 16:39:42 CEST 2019 by igor
